# Example project

Набросок проекта, на котором покажу принцип разделения абстракций

## Задача
Допустим нам необходимо разработать сервис, который предоставляет http api для отправки sms.

Принимаем запрос вида
```json
{
  "sms": {
    "from": string,
    "to": string,
    "text": string
  }
}
```
Отправляем смс, используя какой то 3rd party сервис для отправки смсок.
Кроме того пусть будет требование, что необходимо каждую отправленную смс складывать в какое то хранилище

## Архитектура сервиса

Из поставленной задачи можно сразу выделить несколько уровней абстракции
1. инициализация сервиса -- на этом уровне живёт всякая служебная логкика. Распарсить аргументы командной строки, проинициализировать прилоежение, создать подключения к хранилищам, запустить сервис (см main.go)
2. роутинг -- тут находится логика обработки http запроса. Прочитать body запроса, распарсить его в нужную структуру, поставить какие нибудь заголовки и обработать ответ от приложения (см. router)
3. приложение -- тут живёт бизнес-логика. Если производить аналогию с MVC, то это контроллер, в котором описывается, а что же нужно сделать (cм app)
4. адаптер к 3rd party сервисам -- тут хранится логика перевода терминов нашего приложения в термины 3rd party и обратно. Задача данного уровня предоставить удобный для нашего приложения интерфейс взаимодействия со сторонним сервисом.(cм smsprovider)
5. хранилище -- тут хранится логика работы с хранилищем. Как достать из базы что-то и превратить его в понятные для приложения структуры (см db)

### Зачем это все?
Очевидный вопрос, который должен возникать на данном этапе "Нафига, а главное зачем?"
Для чего городить всю эту сложность, вводить интерфейсы и делать так, чтобы части приложения знали о друг друге как можно меньше

1. управление сложностью. Сервис будет развиваться, будут добавляться требования и т.д. Надо как то это все умещать в голове разработчиков. Разделение на уровни, позволяет нам думать о вещах важных только на этом уровне. Например если я хочу добавить какую нибудь валидацию в процесс отправки  сообщения. я не хочу думать о деталях реализаии подключения к провадеру sms.
2. Изменяемость. Допустим, мы заходим поменять хранилище и вместо psql всё хранить в монге или редисе. Интерфейс сохраниения модели остаётся прежним, нужно будет поменять лишь уровень работы с хранилищем.
3. Расширяемость. Допустим, мы захотим добавить еще одного провайдера sms и в рантайме выбирать через кого отправлять в зависимости от тарифа. Приложение не должно знать как именно там посылается запрос. Оно просто хочет сделать `provider.Send(sms)` и пусть оно там как то само отправится.
4. Тестируемость. На всю эту логику хорошо бы написать тесты. Но как писать тесты, если тестируемый код имеет сайд-эффект в виде отправки куда-то запроса и сохранения чего то в базу? Можно использовать какие нибудь моки. А можно проинициализировать приложение фейковым клиентом, которое будет реализовывать такой же интерфейс, но просто отдавать нужную структуру вместо реального запроса